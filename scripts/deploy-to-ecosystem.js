#!/usr/bin/env node

/**
 * Script de Deployment - GitHub Mastery para Ecossistema MCP
 *
 * Este script automatiza o processo de deployment e integra√ß√£o do GitHub Mastery
 * com o ecossistema MCP, incluindo valida√ß√£o, configura√ß√£o e testes.
 */

import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('Deployment');

class MCPEcosystemDeployment {
  constructor() {
    this.projectRoot = process.cwd();
    this.ecosystemPath = path.join(this.projectRoot, '..', 'MCP_ECOSYSTEM');
    this.integrationConfig = null;
    this.deploymentSteps = [];
  }

  /**
   * Executar deployment completo
   */
  async deploy() {
    try {
      logger.info('üöÄ Iniciando deployment para ecossistema MCP...');

      // Pr√©-valida√ß√µes
      await this.validateEnvironment();
      await this.loadConfiguration();

      // Steps do deployment
      await this.backupCurrentConfig();
      await this.copyIntegrationFiles();
      await this.updateEcosystemConfig();
      await this.installDependencies();
      await this.runIntegrationTests();
      await this.registerWithEcosystem();

      logger.info('‚úÖ Deployment conclu√≠do com sucesso!');
      await this.printDeploymentSummary();
    } catch (error) {
      logger.error('‚ùå Erro durante deployment:', error);
      await this.rollback();
      process.exit(1);
    }
  }

  /**
   * Validar ambiente antes do deployment
   */
  async validateEnvironment() {
    logger.info('üîç Validando ambiente...');

    // Verificar se ecossistema MCP existe
    try {
      await fs.access(this.ecosystemPath);
      logger.info(`‚úÖ Ecossistema MCP encontrado em: ${this.ecosystemPath}`);
    } catch (error) {
      throw new Error(`Ecossistema MCP n√£o encontrado em: ${this.ecosystemPath}`);
    }

    // Verificar Node.js e npm
    try {
      const nodeVersion = execSync('node --version', { encoding: 'utf8' }).trim();
      const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();
      logger.info(`‚úÖ Node.js: ${nodeVersion}, npm: ${npmVersion}`);
    } catch (error) {
      throw new Error('Node.js ou npm n√£o encontrados');
    }

    // Verificar Git
    try {
      const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
      logger.info(`‚úÖ ${gitVersion}`);
    } catch (error) {
      throw new Error('Git n√£o encontrado');
    }

    // Verificar token GitHub
    if (!process.env.GITHUB_TOKEN) {
      logger.warn('‚ö†Ô∏è  GITHUB_TOKEN n√£o definido - configure antes de usar');
    } else {
      logger.info('‚úÖ GITHUB_TOKEN configurado');
    }
  }

  /**
   * Carregar configura√ß√£o de integra√ß√£o
   */
  async loadConfiguration() {
    logger.info('üìã Carregando configura√ß√£o de integra√ß√£o...');

    try {
      const configPath = path.join(this.projectRoot, 'mcp-ecosystem-integration.json');
      const configData = await fs.readFile(configPath, 'utf8');
      this.integrationConfig = JSON.parse(configData);

      logger.info('‚úÖ Configura√ß√£o carregada:', {
        name: this.integrationConfig.integration.name,
        version: this.integrationConfig.integration.version,
        tools: this.integrationConfig.tools.length,
        resources: this.integrationConfig.resources.length,
      });
    } catch (error) {
      throw new Error(`Erro ao carregar configura√ß√£o: ${error.message}`);
    }
  }

  /**
   * Backup da configura√ß√£o atual
   */
  async backupCurrentConfig() {
    logger.info('üíæ Fazendo backup da configura√ß√£o atual...');

    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupDir = path.join(this.projectRoot, 'backups', timestamp);

      await fs.mkdir(backupDir, { recursive: true });

      // Backup dos arquivos de configura√ß√£o
      const filesToBackup = ['mcp-config.json', 'package.json', '.env.example'];

      for (const file of filesToBackup) {
        try {
          const sourcePath = path.join(this.projectRoot, file);
          const targetPath = path.join(backupDir, file);
          await fs.copyFile(sourcePath, targetPath);
          logger.debug(`‚úÖ Backup criado: ${file}`);
        } catch (error) {
          logger.warn(`‚ö†Ô∏è  Arquivo n√£o encontrado para backup: ${file}`);
        }
      }

      this.backupPath = backupDir;
      logger.info(`‚úÖ Backup salvo em: ${backupDir}`);
    } catch (error) {
      throw new Error(`Erro ao criar backup: ${error.message}`);
    }
  }

  /**
   * Copiar arquivos de integra√ß√£o para o ecossistema
   */
  async copyIntegrationFiles() {
    logger.info('üìÅ Copiando arquivos de integra√ß√£o...');

    try {
      const integrationDir = path.join(
        this.ecosystemPath,
        'integrations',
        'github-mastery'
      );
      await fs.mkdir(integrationDir, { recursive: true });

      // Arquivos a serem copiados
      const filesToCopy = [
        {
          source: 'mcp-ecosystem-integration.json',
          target: 'integration-config.json',
        },
        {
          source: 'mcp/github-mcp-server.js',
          target: 'server.js',
        },
        {
          source: 'mcp/ecosystem-adapter.js',
          target: 'adapter.js',
        },
        {
          source: 'api/github-client.js',
          target: 'github-client.js',
        },
        {
          source: 'utils/logger.js',
          target: 'logger.js',
        },
      ];

      for (const file of filesToCopy) {
        const sourcePath = path.join(this.projectRoot, file.source);
        const targetPath = path.join(integrationDir, file.target);

        // Criar diret√≥rio se necess√°rio
        await fs.mkdir(path.dirname(targetPath), { recursive: true });

        await fs.copyFile(sourcePath, targetPath);
        logger.debug(`‚úÖ Copiado: ${file.source} ‚Üí ${file.target}`);
      }

      logger.info(`‚úÖ Arquivos copiados para: ${integrationDir}`);
    } catch (error) {
      throw new Error(`Erro ao copiar arquivos: ${error.message}`);
    }
  }

  /**
   * Atualizar configura√ß√£o do ecossistema
   */
  async updateEcosystemConfig() {
    logger.info('‚öôÔ∏è  Atualizando configura√ß√£o do ecossistema...');

    try {
      const ecosystemConfigPath = path.join(
        this.ecosystemPath,
        'config',
        'mcp-ecosystem.json'
      );

      // Ler configura√ß√£o atual
      let ecosystemConfig;
      try {
        const configData = await fs.readFile(ecosystemConfigPath, 'utf8');
        ecosystemConfig = JSON.parse(configData);
      } catch (error) {
        // Se n√£o existir, criar configura√ß√£o b√°sica
        ecosystemConfig = {
          servers: {},
          integrations: {},
          version: '0.1.0',
        };
      }

      // Adicionar configura√ß√£o do GitHub Mastery
      ecosystemConfig.integrations = ecosystemConfig.integrations || {};
      ecosystemConfig.integrations['github-mastery'] = {
        name: this.integrationConfig.integration.name,
        version: this.integrationConfig.integration.version,
        path: './integrations/github-mastery',
        enabled: true,
        autoStart: true,
        config: this.integrationConfig.server,
      };

      // Salvar configura√ß√£o atualizada
      await fs.writeFile(
        ecosystemConfigPath,
        JSON.stringify(ecosystemConfig, null, 2),
        'utf8'
      );

      logger.info('‚úÖ Configura√ß√£o do ecossistema atualizada');
    } catch (error) {
      throw new Error(`Erro ao atualizar configura√ß√£o: ${error.message}`);
    }
  }

  /**
   * Instalar depend√™ncias
   */
  async installDependencies() {
    logger.info('üì¶ Instalando depend√™ncias...');

    try {
      // Instalar depend√™ncias no projeto atual
      logger.info('Instalando depend√™ncias do GitHub Mastery...');
      execSync('npm install', {
        cwd: this.projectRoot,
        stdio: 'pipe',
      });

      // Instalar depend√™ncias no ecossistema se necess√°rio
      logger.info('Verificando depend√™ncias do ecossistema...');
      const ecosystemPackageJson = path.join(this.ecosystemPath, 'package.json');

      try {
        await fs.access(ecosystemPackageJson);
        execSync('npm install', {
          cwd: this.ecosystemPath,
          stdio: 'pipe',
        });
        logger.info('‚úÖ Depend√™ncias do ecossistema atualizadas');
      } catch (error) {
        logger.warn('‚ö†Ô∏è  package.json do ecossistema n√£o encontrado');
      }

      logger.info('‚úÖ Depend√™ncias instaladas');
    } catch (error) {
      throw new Error(`Erro ao instalar depend√™ncias: ${error.message}`);
    }
  }

  /**
   * Executar testes de integra√ß√£o
   */
  async runIntegrationTests() {
    logger.info('üß™ Executando testes de integra√ß√£o...');

    try {
      // Teste b√°sico: verificar se os arquivos existem
      const integrationDir = path.join(
        this.ecosystemPath,
        'integrations',
        'github-mastery'
      );
      const requiredFiles = ['server.js', 'adapter.js', 'integration-config.json'];

      for (const file of requiredFiles) {
        const filePath = path.join(integrationDir, file);
        await fs.access(filePath);
        logger.debug(`‚úÖ Arquivo encontrado: ${file}`);
      }

      // Teste: validar JSON de configura√ß√£o
      const configPath = path.join(integrationDir, 'integration-config.json');
      const configData = await fs.readFile(configPath, 'utf8');
      JSON.parse(configData); // Vai lan√ßar erro se JSON inv√°lido

      logger.info('‚úÖ Testes de integra√ß√£o passaram');
    } catch (error) {
      throw new Error(`Testes de integra√ß√£o falharam: ${error.message}`);
    }
  }

  /**
   * Registrar com o ecossistema
   */
  async registerWithEcosystem() {
    logger.info('üìù Registrando com o ecossistema...');

    try {
      // Criar arquivo de registro
      const registryPath = path.join(
        this.ecosystemPath,
        'registry',
        'github-mastery.json'
      );
      await fs.mkdir(path.dirname(registryPath), { recursive: true });

      const registryEntry = {
        id: 'github-mastery',
        name: this.integrationConfig.integration.name,
        version: this.integrationConfig.integration.version,
        type: 'mcp-server',
        description: this.integrationConfig.integration.description,
        capabilities: this.integrationConfig.server.capabilities,
        tools: this.integrationConfig.tools.map(t => t.name),
        resources: this.integrationConfig.resources.map(r => r.uri),
        registered_at: new Date().toISOString(),
        status: 'active',
      };

      await fs.writeFile(registryPath, JSON.stringify(registryEntry, null, 2), 'utf8');

      logger.info('‚úÖ Registrado no ecossistema');
    } catch (error) {
      throw new Error(`Erro ao registrar: ${error.message}`);
    }
  }

  /**
   * Imprimir resumo do deployment
   */
  async printDeploymentSummary() {
    const summary = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                          DEPLOYMENT CONCLU√çDO                               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Projeto: ${this.integrationConfig.integration.name.padEnd(60)} ‚ïë
‚ïë Vers√£o:  ${this.integrationConfig.integration.version.padEnd(60)} ‚ïë
‚ïë Ferramentas: ${String(this.integrationConfig.tools.length).padEnd(56)} ‚ïë
‚ïë Recursos:    ${String(this.integrationConfig.resources.length).padEnd(56)} ‚ïë
‚ïë                                                                              ‚ïë
‚ïë Localiza√ß√£o no Ecossistema:                                                 ‚ïë
‚ïë ${this.ecosystemPath.padEnd(76)} ‚ïë
‚ïë                                                                              ‚ïë
‚ïë Pr√≥ximos Passos:                                                             ‚ïë
‚ïë 1. Configure GITHUB_TOKEN no ambiente                                       ‚ïë
‚ïë 2. Inicie o ecossistema MCP                                                  ‚ïë
‚ïë 3. Teste as ferramentas GitHub via MCP                                      ‚ïë
‚ïë                                                                              ‚ïë
‚ïë Comandos √öteis:                                                              ‚ïë
‚ïë ‚Ä¢ Iniciar adaptador: node mcp/ecosystem-adapter.js                          ‚ïë
‚ïë ‚Ä¢ Testar servidor: node mcp/github-mcp-server.js                            ‚ïë
‚ïë ‚Ä¢ Ver logs: npm run logs                                                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`;

    console.log(summary);

    // Salvar resumo em arquivo
    const summaryPath = path.join(this.projectRoot, 'deployment-summary.txt');
    await fs.writeFile(summaryPath, summary, 'utf8');
    logger.info(`üìÑ Resumo salvo em: ${summaryPath}`);
  }

  /**
   * Rollback em caso de erro
   */
  async rollback() {
    logger.warn('üîÑ Iniciando rollback...');

    try {
      if (this.backupPath) {
        // Restaurar arquivos do backup
        const filesToRestore = await fs.readdir(this.backupPath);

        for (const file of filesToRestore) {
          const backupFile = path.join(this.backupPath, file);
          const targetFile = path.join(this.projectRoot, file);

          await fs.copyFile(backupFile, targetFile);
          logger.debug(`‚úÖ Restaurado: ${file}`);
        }

        logger.info('‚úÖ Rollback conclu√≠do');
      }
    } catch (error) {
      logger.error('‚ùå Erro durante rollback:', error);
    }
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const deployment = new MCPEcosystemDeployment();

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Uso: node scripts/deploy-to-ecosystem.js [op√ß√µes]

Op√ß√µes:
  --help, -h     Mostrar esta ajuda
  --dry-run      Simular deployment sem fazer altera√ß√µes
  --verbose      Modo verboso
  --rollback     Restaurar backup mais recente

Exemplos:
  node scripts/deploy-to-ecosystem.js
  node scripts/deploy-to-ecosystem.js --dry-run
  node scripts/deploy-to-ecosystem.js --verbose
`);
    return;
  }

  if (args.includes('--dry-run')) {
    logger.info('üîç Modo dry-run: simulando deployment...');
    // Implementar simula√ß√£o se necess√°rio
    return;
  }

  if (args.includes('--rollback')) {
    logger.info('üîÑ Executando rollback...');
    await deployment.rollback();
    return;
  }

  // Configurar n√≠vel de log
  if (args.includes('--verbose')) {
    // Implementar modo verboso se necess√°rio
  }

  // Executar deployment
  await deployment.deploy();
}

// Executar se chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('Erro fatal:', error);
    process.exit(1);
  });
}

export { MCPEcosystemDeployment };
